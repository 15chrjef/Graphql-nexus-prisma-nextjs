### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input documentCreateOneWithoutUserInput {
  connect: documentWhereUniqueInput
  create: documentCreateWithoutUserInput
}

input documentCreateWithoutUserInput {
  created_at: DateTime
  generated_blog_text: String!
  sample_blog_text: String!
  title: String!
  updated_at: DateTime
}

input documentUpdateOneWithoutUserInput {
  connect: documentWhereUniqueInput
  create: documentCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: documentUpdateWithoutUserDataInput
  upsert: documentUpsertWithoutUserInput
}

input documentUpdateWithoutUserDataInput {
  created_at: DateTime
  generated_blog_text: String
  sample_blog_text: String
  title: String
  updated_at: DateTime
}

input documentUpsertWithoutUserInput {
  create: documentCreateWithoutUserInput!
  update: documentUpdateWithoutUserDataInput!
}

input documentWhereInput {
  AND: [documentWhereInput!]
  created_at: DateTimeFilter
  generated_blog_text: StringFilter
  id: IntFilter
  NOT: [documentWhereInput!]
  OR: [documentWhereInput!]
  sample_blog_text: StringFilter
  title: StringFilter
  updated_at: DateTimeFilter
  user: userWhereInput
  user_id: IntFilter
}

input documentWhereUniqueInput {
  id: Int
  user_id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  bigRedButton: String
  createOneuser(data: userCreateInput!): user!
  deleteManyuser(where: userWhereInput): BatchPayload!
  deleteOneuser(where: userWhereUniqueInput!): user
  signup(email: String!, first_name: String!, last_name: String!, password: String!): user
  updateManyuser(data: userUpdateManyMutationInput!, where: userWhereInput): BatchPayload!
  updateOneuser(data: userUpdateInput!, where: userWhereUniqueInput!): user
}

type Query {
  allUsers: [user!]
  user(where: userWhereUniqueInput!): user
  users(after: userWhereUniqueInput, before: userWhereUniqueInput, first: Int, last: Int): [user!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type user {
  created_at: DateTime!
  email: String!
  first_name: String!
  id: Int!
  last_name: String!
  password: String!
  updated_at: DateTime!
}

input userCreateInput {
  created_at: DateTime
  document: documentCreateOneWithoutUserInput
  email: String!
  first_name: String!
  last_name: String!
  password: String!
  updated_at: DateTime
}

input userUpdateInput {
  created_at: DateTime
  document: documentUpdateOneWithoutUserInput
  email: String
  first_name: String
  last_name: String
  password: String
  updated_at: DateTime
}

input userUpdateManyMutationInput {
  created_at: DateTime
  email: String
  first_name: String
  last_name: String
  password: String
  updated_at: DateTime
}

input userWhereInput {
  AND: [userWhereInput!]
  created_at: DateTimeFilter
  document: documentWhereInput
  email: StringFilter
  first_name: StringFilter
  id: IntFilter
  last_name: StringFilter
  NOT: [userWhereInput!]
  OR: [userWhereInput!]
  password: StringFilter
  updated_at: DateTimeFilter
}

input userWhereUniqueInput {
  email: String
  id: Int
}
